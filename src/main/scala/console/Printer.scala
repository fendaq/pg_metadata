package console

import core.{Logger, TableDTO}

import scala.language.implicitConversions

case class Printer()(implicit cfg: Logger) {
  val templateColumns = "|%2s|%15s|%30s|%30s|%30s|%15s|\n"
  val templateColumnsDetails = "|%2s|%30s|%60s|%20s|%20s|%20s|%20s|%20s|%20s|\n"
  val templateFK = "|%2s|%46s|%30s|%30s|%15s|%15s|\n"
  val templateIndexes = "|%2s|%46s|\n"
  val templateChecks = "|%2s|%46s|\n"

  def *(value: String*): Unit =
    if (value.isEmpty) cfg.log("") else value.foreach(cfg.log)

  def **(format: String, args: String*): Unit =
    cfg.logF(format, args: _*)

  implicit def optToString(option: Option[Any]): String =
    option.getOrElse("").toString

  implicit def boolToString(b: Boolean): String =
    if (b) "YES" else ""

  def printCollectedInfo(e: Seq[TableDTO]) = {
    if (cfg.debug) {
      *("=" * 150)
      e.foreach(table => {

        *("*" * 30)
        *("@ Table " + table.name)
        *("*" * 30)

        *()
        **(templateColumns, "#",
          "Primary Key",
          "Column Name",
          "Database Type",
          "AutoGenerated Primary Key",
          "Nullable")
        table.column.zipWithIndex.foreach { case (c, n) =>
          **(templateColumns,
            ++(n).toString,
            c.primary,
            c.name,
            c.dbType,
            c.hasSequences,
            c.nullable)
        }

        *()
        *("Columns limits")
        **(templateColumnsDetails, "#",
          "Column Name",
          "Default value",
          "Char max len",
          "Char octet len",
          "Numeric prec.",
          "Numeric prec. radix",
          "Numeric scale",
          "Datetime prec.")
        table.column.zipWithIndex.foreach { case (c, n) =>
          **(templateColumnsDetails,
            ++(n).toString,
            c.name,
            c.column_default,
            c.character_maximum_length,
            c.character_octet_length,
            c.numeric_precision,
            c.numeric_precision_radix,
            c.numeric_scale,
            c.datetime_precision)
        }

        table.foreignKeys.getOrElse(Nil).foreach { fk =>
          *()
          *("Foreign key " + fk.name)
          **(templateFK, "#", "Column name", "To Table", "To Column Name", "On Update", "On Delete")
          **(templateFK, "1", fk.column.name,
            fk.references_to_table.name,
            fk.references_to_column.name,
            fk.action_on_update.toString,
            fk.action_on_delete.toString)
        }

        table.uniqueIndexes.getOrElse(Nil)foreach { idx =>
          *()
          *("Unique index " + idx.name)
          **(templateIndexes, "#", "Column Name")

          idx.columns.zipWithIndex.foreach { case (idxColumn, n) =>
            **(templateIndexes, ++(n).toString, idxColumn.name)
          }
        }

        if (table.checks.nonEmpty) {
          *()
          *("Checks")
          **(templateChecks, "#", "Check name")

          table.checks.getOrElse(Nil).zipWithIndex.foreach { case (check, n) =>
            **(templateChecks, ++(n).toString, check.name)
          }
        }

        *()
        *("=" * 150)
      })
    }
  }

  def ++(int: Int) = int + 1
}
